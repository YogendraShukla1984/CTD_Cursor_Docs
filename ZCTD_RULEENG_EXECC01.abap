*&---------------------------------------------------------------------*
*& Include ZCTD_RULEENG_EXECC01
*&---------------------------------------------------------------------*
*& Purpose: Main report class with all business logic
*& Author: Generated by Cursor AI
*& Date: 2026-01-16
*&---------------------------------------------------------------------*

*----------------------------------------------------------------------*
* CLASS lcl_report DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_report DEFINITION.
  PUBLIC SECTION.
    METHODS:
      initialization,
      validate_selection_screen,
      main_processing,
      display_results.

  PRIVATE SECTION.
    METHODS:
      " Step 1: Fetch Data
      fetch_eligible_trips
        RETURNING VALUE(rv_subrc) TYPE sysubrc,

      fetch_shipment_details
        IMPORTING iv_lifnr    TYPE lifnr
                  iv_truck_no TYPE ytruck_no
                  iv_trip_no  TYPE zsce_ctd_hdr-trip_no
        EXPORTING et_trip_itm TYPE gty_t_trip_itm
        RETURNING VALUE(rv_subrc) TYPE sysubrc,

      " Step 2: RuleMap Configuration
      load_rulemap_config
        RETURNING VALUE(rv_subrc) TYPE sysubrc,

      determine_rulemap
        IMPORTING is_trip_hdr          TYPE zsce_ctd_hdr
                  it_trip_itm          TYPE gty_t_trip_itm
        EXPORTING ev_business_id       TYPE char10
                  ev_sub_business_id   TYPE char10
                  ev_rulemap_id        TYPE char20
        RETURNING VALUE(rv_subrc)      TYPE sysubrc,

      " Step 3: Rule Execution
      process_all_trips,

      execute_trip_rules
        IMPORTING iv_rulemap_id     TYPE char20
        CHANGING  cs_trip_hdr       TYPE zsce_ctd_hdr
                  ct_trip_itm       TYPE gty_t_trip_itm
                  cs_trip_proc      TYPE gty_trip_proc
        RETURNING VALUE(rv_subrc)   TYPE sysubrc,

      execute_eligibility_rules
        IMPORTING iv_rulemap_id     TYPE char20
                  it_elig_rules     TYPE gty_t_rulemap_proc
        CHANGING  cs_trip_hdr       TYPE zsce_ctd_hdr
                  ct_trip_itm       TYPE gty_t_trip_itm
                  cs_trip_proc      TYPE gty_trip_proc
                  cv_elig_found     TYPE abap_bool
        RETURNING VALUE(rv_subrc)   TYPE sysubrc,

      call_rule_fm
        IMPORTING iv_fm_name        TYPE funcname
                  it_trip_hdr_in    TYPE gty_t_trip_hdr
                  it_trip_itm_in    TYPE gty_t_trip_itm
        EXPORTING et_trip_hdr_out   TYPE gty_t_trip_hdr
                  et_trip_itm_out   TYPE gty_t_trip_itm
                  ev_rule_status    TYPE char1
                  ev_rule_message   TYPE string
                  ev_trips_proc     TYPE i
                  ev_trips_elig     TYPE i
        RETURNING VALUE(rv_subrc)   TYPE sysubrc,

      execute_calculation_rule
        IMPORTING it_calc_rules     TYPE gty_t_rulemap_proc
        CHANGING  cs_trip_hdr       TYPE zsce_ctd_hdr
                  ct_trip_itm       TYPE gty_t_trip_itm
                  cs_trip_proc      TYPE gty_trip_proc
        RETURNING VALUE(rv_subrc)   TYPE sysubrc,

      evaluate_condition
        IMPORTING is_trip_hdr       TYPE zsce_ctd_hdr
                  it_trip_itm       TYPE gty_t_trip_itm
                  iv_condition      TYPE char255
        RETURNING VALUE(rv_result)  TYPE abap_bool,

      " Step 4: Database Operations
      update_database
        RETURNING VALUE(rv_subrc) TYPE sysubrc,

      " Display & Logging
      prepare_alv_output,
      display_alv,
      write_job_log,
      build_fieldcat
        CHANGING ct_fieldcat TYPE lvc_t_fcat,

      " Application Log
      init_application_log,
      add_log_message
        IMPORTING iv_msgty  TYPE symsgty
                  iv_msgtext TYPE string
                  iv_param1  TYPE any
                  iv_param2  TYPE any,
      save_application_log,
      log_execution_summary,

      " Helper Methods
      append_remark
        IMPORTING iv_remark TYPE string
        CHANGING  cv_remarks TYPE zsce_ctd_hdr-ctd_ruleeng_remarks.

ENDCLASS.

*----------------------------------------------------------------------*
* CLASS lcl_report IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_report IMPLEMENTATION.

  METHOD initialization.
    CLEAR: gt_trip_hdr,
           gt_trip_itm,
           gt_trip_proc,
           gt_rulemap_det,
           gt_rulemap_proc,
           gt_rule_result,
           gt_alv_output,
           gv_trips_fetched,
           gv_trips_proc,
           gv_trips_eligible,
           gv_trips_error.

    " Initialize application log
    me->init_application_log( ).
  ENDMETHOD.

  METHOD validate_selection_screen.
    DATA: lv_date_diff TYPE i,
          lv_message   TYPE string.

    " Validation 1: From Date <= To Date
    IF p_fdate > p_tdate.
      MESSAGE 'From Date cannot be greater than To Date' TYPE 'E'.
    ENDIF.

    " Validation 2: Date range reasonableness (<= 365 days)
    lv_date_diff = p_tdate - p_fdate.
    IF lv_date_diff > 365.
      MESSAGE 'Date range cannot exceed 1 year' TYPE 'E'.
    ENDIF.

    " Validation 3: At least one execution mode selected
    IF p_fgnd = space AND p_bgnd = space.
      MESSAGE 'Select at least one execution mode' TYPE 'E'.
    ENDIF.

    " Log validation success
    me->add_log_message(
      iv_msgty  = 'I'
      iv_msgtext = 'Input validation passed'
      iv_param1  = space
      iv_param2  = space ).
  ENDMETHOD.

  METHOD main_processing.
    DATA: lv_subrc TYPE sysubrc.

    GET TIME STAMP FIELD gv_start_time.

    " Step 1: Fetch Eligible Trips
    lv_subrc = me->fetch_eligible_trips( ).
    IF lv_subrc <> 0.
      me->add_log_message(
        iv_msgty  = 'I'
        iv_msgtext = gc_msg_no_trips
        iv_param1  = space
        iv_param2  = space ).
      RETURN.
    ENDIF.

    " Step 2: Load RuleMap Configuration
    lv_subrc = me->load_rulemap_config( ).
    IF lv_subrc <> 0.
      me->add_log_message(
        iv_msgty  = 'E'
        iv_msgtext = 'Failed to load RuleMap configuration'
        iv_param1  = space
        iv_param2  = space ).
      RETURN.
    ENDIF.

    " Step 3: Process Each Trip
    me->process_all_trips( ).

    " Step 4: Database Update (if not simulation)
    IF p_simul = space.
      lv_subrc = me->update_database( ).
      IF lv_subrc <> 0.
        me->add_log_message(
          iv_msgty  = 'E'
          iv_msgtext = gc_msg_db_error
          iv_param1  = space
          iv_param2  = space ).
        RETURN.
      ENDIF.
    ELSE.
      me->add_log_message(
        iv_msgty  = 'I'
        iv_msgtext = 'Simulation mode - No database updates performed'
        iv_param1  = space
        iv_param2  = space ).
    ENDIF.

    " Step 5: Calculate Runtime
    GET TIME STAMP FIELD gv_end_time.
    gv_runtime = gv_end_time - gv_start_time.

    " Log summary
    me->log_execution_summary( ).
  ENDMETHOD.

  METHOD fetch_eligible_trips.
    DATA: lv_count TYPE i,
          lo_exc   TYPE REF TO cx_root,
          lv_error_text TYPE string.

    CLEAR: gt_trip_hdr, rv_subrc.

    TRY.
        " Fetch trip headers
        SELECT *
          FROM zsce_ctd_hdr
          INTO TABLE gt_trip_hdr
          WHERE trip_status = gc_stat_confirmed
            AND created_date BETWEEN p_fdate AND p_tdate
            AND del_ind <> 'X'.

        IF sy-subrc <> 0.
          rv_subrc = 4.
          RETURN.
        ENDIF.

        " Check if any trips found
        DESCRIBE TABLE gt_trip_hdr LINES lv_count.
        IF lv_count = 0.
          rv_subrc = 4.
          RETURN.
        ENDIF.

        gv_trips_fetched = lv_count.

        " Log success
        me->add_log_message(
          iv_msgty  = 'S'
          iv_msgtext = 'Trips fetched successfully'
          iv_param1  = lv_count
          iv_param2  = space ).

      CATCH cx_root INTO lo_exc.
        lv_error_text = lo_exc->get_text( ).
        rv_subrc = 8.
        me->add_log_message(
          iv_msgty  = 'E'
          iv_msgtext = lv_error_text
          iv_param1  = space
          iv_param2  = space ).
    ENDTRY.
  ENDMETHOD.

  METHOD fetch_shipment_details.
    DATA: lv_count TYPE i,
          lo_exc   TYPE REF TO cx_root,
          lv_error_text TYPE string.

    CLEAR: et_trip_itm, rv_subrc.

    TRY.
        SELECT *
          FROM zsce_ctd_itm
          INTO TABLE et_trip_itm
          WHERE lifnr = iv_lifnr
            AND truck_no = iv_truck_no
            AND trip_no = iv_trip_no
            AND del_ind <> 'X'.

        IF sy-subrc <> 0.
          rv_subrc = 4.
          RETURN.
        ENDIF.

        DESCRIBE TABLE et_trip_itm LINES lv_count.
        IF lv_count = 0.
          rv_subrc = 4.
          RETURN.
        ENDIF.

      CATCH cx_root INTO lo_exc.
        lv_error_text = lo_exc->get_text( ).
        rv_subrc = 8.
        me->add_log_message(
          iv_msgty  = 'E'
          iv_msgtext = lv_error_text
          iv_param1  = space
          iv_param2  = iv_trip_no ).
    ENDTRY.
  ENDMETHOD.

  METHOD load_rulemap_config.
    DATA: lv_count TYPE i,
          lo_exc   TYPE REF TO cx_root,
          lv_error_text TYPE string.

    CLEAR: gt_rulemap_det, gt_rulemap_proc, rv_subrc.

    TRY.
        " Load RuleMap Determination Configuration
        " Note: Table ZCTD_RULEMAP_DET needs to be created
        " For now using placeholder logic
        CLEAR gt_rulemap_det.

        " Load RuleMap Process Configuration
        " Note: Table ZCTD_RULEMAP_PROC needs to be created
        " For now using placeholder logic
        CLEAR gt_rulemap_proc.

        " Log success
        me->add_log_message(
          iv_msgty  = 'S'
          iv_msgtext = 'RuleMap configuration loaded'
          iv_param1  = space
          iv_param2  = space ).

      CATCH cx_root INTO lo_exc.
        lv_error_text = lo_exc->get_text( ).
        rv_subrc = 8.
        me->add_log_message(
          iv_msgty  = 'E'
          iv_msgtext = lv_error_text
          iv_param1  = space
          iv_param2  = space ).
    ENDTRY.
  ENDMETHOD.

  METHOD determine_rulemap.
    DATA: lw_rulemap_det TYPE gty_rulemap_det,
          lv_area        TYPE yarea.

    CLEAR: ev_business_id, ev_sub_business_id, ev_rulemap_id, rv_subrc.

    " Extract Business and Sub-Business ID from area
    lv_area = is_trip_hdr-area.

    " Example logic - customize based on business rules
    CASE lv_area.
      WHEN 'R1'.
        ev_business_id = 'RETAIL'.
        ev_sub_business_id = 'GROCERY'.
      WHEN 'R2'.
        ev_business_id = 'RETAIL'.
        ev_sub_business_id = 'FMCG'.
      WHEN 'W1'.
        ev_business_id = 'WHOLESALE'.
        ev_sub_business_id = 'BULK'.
      WHEN OTHERS.
        ev_business_id = 'DEFAULT'.
        ev_sub_business_id = 'GENERAL'.
    ENDCASE.

    " Find matching RuleMap in configuration
    READ TABLE gt_rulemap_det INTO lw_rulemap_det
      WITH KEY business_id = ev_business_id
               sub_business_id = ev_sub_business_id
      BINARY SEARCH.

    IF sy-subrc <> 0.
      " Try with wildcard sub-business
      READ TABLE gt_rulemap_det INTO lw_rulemap_det
        WITH KEY business_id = ev_business_id
                 sub_business_id = '*'
        BINARY SEARCH.
    ENDIF.

    IF sy-subrc = 0.
      ev_rulemap_id = lw_rulemap_det-rulemap_id.
      rv_subrc = 0.

      me->add_log_message(
        iv_msgty  = 'S'
        iv_msgtext = 'RuleMap determined'
        iv_param1  = space
        iv_param2  = is_trip_hdr-trip_no ).
    ELSE.
      rv_subrc = 4.
      me->add_log_message(
        iv_msgty  = 'E'
        iv_msgtext = gc_msg_no_rulemap
        iv_param1  = space
        iv_param2  = is_trip_hdr-trip_no ).
    ENDIF.
  ENDMETHOD.

  METHOD process_all_trips.
    DATA: lw_trip_hdr  TYPE zsce_ctd_hdr,
          lw_trip_proc TYPE gty_trip_proc,
          lt_trip_itm  TYPE gty_t_trip_itm,
          lv_subrc     TYPE sysubrc.

    FIELD-SYMBOLS: <lfs_trip_hdr> TYPE zsce_ctd_hdr,
                   <lfs_itm>       TYPE zsce_ctd_itm.

    LOOP AT gt_trip_hdr INTO lw_trip_hdr.

      CLEAR: lw_trip_proc, lt_trip_itm, lv_subrc.

      " Initialize trip processing structure
      lw_trip_proc-lifnr = lw_trip_hdr-lifnr.
      lw_trip_proc-truck_no = lw_trip_hdr-truck_no.
      lw_trip_proc-trip_no = lw_trip_hdr-trip_no.
      lw_trip_proc-prev_status = lw_trip_hdr-trip_status.
      GET TIME STAMP FIELD lw_trip_proc-processed_on.

      " Fetch Shipment Details
      lv_subrc = me->fetch_shipment_details(
        EXPORTING
          iv_lifnr    = lw_trip_hdr-lifnr
          iv_truck_no = lw_trip_hdr-truck_no
          iv_trip_no  = lw_trip_hdr-trip_no
        IMPORTING
          et_trip_itm = lt_trip_itm ).

      IF lv_subrc <> 0.
        lw_trip_proc-exec_status = gc_exec_skipped.
        lw_trip_proc-exec_message = 'No shipment details found'.
        APPEND lw_trip_proc TO gt_trip_proc.
        gv_trips_error = gv_trips_error + 1.
        CONTINUE.
      ENDIF.

      " Determine RuleMap ID
      lv_subrc = me->determine_rulemap(
        EXPORTING
          is_trip_hdr  = lw_trip_hdr
          it_trip_itm  = lt_trip_itm
        IMPORTING
          ev_business_id     = lw_trip_proc-business_id
          ev_sub_business_id = lw_trip_proc-sub_business_id
          ev_rulemap_id      = lw_trip_proc-rulemap_id ).

      IF lv_subrc <> 0.
        lw_trip_proc-exec_status = gc_exec_error.
        lw_trip_proc-exec_message = gc_msg_no_rulemap.
        lw_trip_hdr-trip_status = gc_stat_error.
        APPEND lw_trip_proc TO gt_trip_proc.
        gv_trips_error = gv_trips_error + 1.

        " Update trip header with error status
        MODIFY gt_trip_hdr FROM lw_trip_hdr
          TRANSPORTING trip_status
          WHERE trip_no = lw_trip_hdr-trip_no.

        CONTINUE.
      ENDIF.

      " Execute Rules for this trip
      lv_subrc = me->execute_trip_rules(
        EXPORTING
          iv_rulemap_id = lw_trip_proc-rulemap_id
        CHANGING
          cs_trip_hdr   = lw_trip_hdr
          ct_trip_itm   = lt_trip_itm
          cs_trip_proc  = lw_trip_proc ).

      " Update trip header in global table
      MODIFY gt_trip_hdr FROM lw_trip_hdr
        WHERE trip_no = lw_trip_hdr-trip_no.

      " Update trip items in global table
      LOOP AT lt_trip_itm ASSIGNING <lfs_itm>.
        MODIFY gt_trip_itm FROM <lfs_itm>
          WHERE lifnr = <lfs_itm>-lifnr
            AND truck_no = <lfs_itm>-truck_no
            AND trip_no = <lfs_itm>-trip_no
            AND counter = <lfs_itm>-counter.

        IF sy-subrc <> 0.
          APPEND <lfs_itm> TO gt_trip_itm.
        ENDIF.
      ENDLOOP.

      " Append trip processing result
      APPEND lw_trip_proc TO gt_trip_proc.

      " Update counters
      gv_trips_proc = gv_trips_proc + 1.
      IF lw_trip_proc-exec_status = gc_exec_success.
        gv_trips_eligible = gv_trips_eligible + 1.
      ELSEIF lw_trip_proc-exec_status = gc_exec_error.
        gv_trips_error = gv_trips_error + 1.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.

  METHOD execute_trip_rules.
    DATA: lt_elig_rules TYPE gty_t_rulemap_proc,
          lt_calc_rules TYPE gty_t_rulemap_proc,
          lv_elig_found TYPE abap_bool,
          lv_subrc      TYPE sysubrc,
          lv_calc_count TYPE i.

    FIELD-SYMBOLS: <lfs_rule> TYPE gty_rulemap_proc.

    CLEAR: rv_subrc, lv_elig_found.

    " Step 1: Filter rules for this RuleMap
    LOOP AT gt_rulemap_proc ASSIGNING <lfs_rule>
      WHERE rulemap_id = iv_rulemap_id.

      IF <lfs_rule>-process_type = gc_proc_elig_rule.
        APPEND <lfs_rule> TO lt_elig_rules.
      ELSEIF <lfs_rule>-process_type = gc_proc_calc.
        APPEND <lfs_rule> TO lt_calc_rules.
      ENDIF.
    ENDLOOP.

    " Step 2: Validate rule configuration
    IF lt_elig_rules IS INITIAL.
      cs_trip_proc-exec_status = gc_exec_error.
      cs_trip_proc-exec_message = gc_msg_no_rules.
      rv_subrc = 4.
      RETURN.
    ENDIF.

    " Check for multiple CALC rules
    DESCRIBE TABLE lt_calc_rules LINES lv_calc_count.
    IF lv_calc_count > 1.
      cs_trip_proc-exec_status = gc_exec_error.
      cs_trip_proc-exec_message = 'Multiple CALC rules configured'.
      rv_subrc = 4.
      RETURN.
    ENDIF.

    " Step 3: Execute Eligibility Rules
    lv_subrc = me->execute_eligibility_rules(
      EXPORTING
        iv_rulemap_id = iv_rulemap_id
        it_elig_rules = lt_elig_rules
      CHANGING
        cs_trip_hdr   = cs_trip_hdr
        ct_trip_itm   = ct_trip_itm
        cs_trip_proc  = cs_trip_proc
        cv_elig_found = lv_elig_found ).

    IF lv_subrc <> 0.
      rv_subrc = lv_subrc.
      RETURN.
    ENDIF.

    " Step 4: Execute Calculation Rule (if configured and eligible)
    IF lt_calc_rules IS NOT INITIAL AND lv_elig_found = abap_true.
      lv_subrc = me->execute_calculation_rule(
        EXPORTING
          it_calc_rules = lt_calc_rules
        CHANGING
          cs_trip_hdr   = cs_trip_hdr
          ct_trip_itm   = ct_trip_itm
          cs_trip_proc  = cs_trip_proc ).
    ENDIF.

    " Step 5: Finalize trip status and remarks
    IF lv_elig_found = abap_true.
      cs_trip_hdr-trip_status = gc_stat_executed.
      cs_trip_hdr-modified_by = sy-uname.
      cs_trip_hdr-modified_date = sy-datum.
      cs_trip_proc-trip_status = gc_stat_executed.
      cs_trip_proc-exec_status = gc_exec_success.
    ELSE.
      cs_trip_proc-exec_status = gc_exec_warning.
      cs_trip_proc-exec_message = 'No eligibility rule satisfied'.
    ENDIF.
  ENDMETHOD.

  METHOD execute_eligibility_rules.
    DATA: lt_trip_hdr_in  TYPE gty_t_trip_hdr,
          lt_trip_itm_in  TYPE gty_t_trip_itm,
          lt_trip_hdr_out TYPE gty_t_trip_hdr,
          lt_trip_itm_out TYPE gty_t_trip_itm,
          lw_trip_hdr_out TYPE zsce_ctd_hdr,
          lv_rule_status  TYPE char1,
          lv_rule_message TYPE string,
          lv_trips_proc   TYPE i,
          lv_trips_elig   TYPE i,
          lw_rule_result  TYPE gty_rule_result,
          lv_subrc        TYPE sysubrc.

    FIELD-SYMBOLS: <lfs_rule> TYPE gty_rulemap_proc.

    CLEAR: cv_elig_found, rv_subrc.

    " Prepare input (single trip)
    APPEND cs_trip_hdr TO lt_trip_hdr_in.
    lt_trip_itm_in = ct_trip_itm.

    " Loop through eligibility rules in SEQ_NO order
    LOOP AT it_elig_rules ASSIGNING <lfs_rule>.

      CLEAR: lv_rule_status,
             lv_rule_message,
             lv_trips_proc,
             lv_trips_elig,
             lw_rule_result,
             lt_trip_hdr_out,
             lt_trip_itm_out.

      " Call rule function module dynamically
      lv_subrc = me->call_rule_fm(
        EXPORTING
          iv_fm_name      = <lfs_rule>-fm_name
          it_trip_hdr_in  = lt_trip_hdr_in
          it_trip_itm_in  = lt_trip_itm_in
        IMPORTING
          et_trip_hdr_out = lt_trip_hdr_out
          et_trip_itm_out = lt_trip_itm_out
          ev_rule_status  = lv_rule_status
          ev_rule_message = lv_rule_message
          ev_trips_proc   = lv_trips_proc
          ev_trips_elig   = lv_trips_elig ).

      " Log rule execution
      lw_rule_result-trip_no = cs_trip_hdr-trip_no.
      lw_rule_result-rulemap_id = iv_rulemap_id.
      lw_rule_result-rule_seq = <lfs_rule>-seq_no.
      lw_rule_result-rule_fm = <lfs_rule>-fm_name.
      lw_rule_result-rule_status = lv_rule_status.
      lw_rule_result-rule_message = lv_rule_message.
      GET TIME STAMP FIELD lw_rule_result-exec_timestamp.
      APPEND lw_rule_result TO gt_rule_result.

      " Evaluate rule result
      CASE lv_rule_status.
        WHEN gc_rule_success.
          " Rule succeeded - update working tables and STOP
          READ TABLE lt_trip_hdr_out INTO lw_trip_hdr_out INDEX 1.
          IF sy-subrc = 0.
            cs_trip_hdr = lw_trip_hdr_out.
          ENDIF.
          ct_trip_itm = lt_trip_itm_out.

          cv_elig_found = abap_true.

          " Append rule to sequence string
          IF cs_trip_proc-rule_seq IS INITIAL.
            cs_trip_proc-rule_seq = <lfs_rule>-seq_no.
          ELSE.
            CONCATENATE cs_trip_proc-rule_seq '->' <lfs_rule>-seq_no
              INTO cs_trip_proc-rule_seq.
          ENDIF.

          " Append message to remarks
          me->append_remark(
            EXPORTING
              iv_remark = lv_rule_message
            CHANGING
              cv_remarks = cs_trip_hdr-ctd_ruleeng_remarks ).

          " Log success and EXIT
          me->add_log_message(
            iv_msgty  = 'S'
            iv_msgtext = lv_rule_message
            iv_param1  = <lfs_rule>-seq_no
            iv_param2  = cs_trip_hdr-trip_no ).

          EXIT.  " Stop processing further rules

        WHEN gc_rule_not_appld.
          " Rule not applicable - continue to next rule
          me->add_log_message(
            iv_msgty  = 'I'
            iv_msgtext = lv_rule_message
            iv_param1  = <lfs_rule>-seq_no
            iv_param2  = cs_trip_hdr-trip_no ).

        WHEN gc_rule_error.
          " Rule execution error - stop processing
          cs_trip_proc-exec_status = gc_exec_error.
          cs_trip_proc-exec_message = lv_rule_message.
          rv_subrc = 8.

          me->add_log_message(
            iv_msgty  = 'E'
            iv_msgtext = lv_rule_message
            iv_param1  = <lfs_rule>-seq_no
            iv_param2  = cs_trip_hdr-trip_no ).

          EXIT.

        WHEN OTHERS.
          " Unknown status - treat as error
          cs_trip_proc-exec_status = gc_exec_error.
          cs_trip_proc-exec_message = 'Unknown rule status returned'.
          rv_subrc = 8.
          EXIT.
      ENDCASE.

    ENDLOOP.
  ENDMETHOD.

  METHOD call_rule_fm.
    DATA: lv_exc_text TYPE string.

    CLEAR: et_trip_hdr_out,
           et_trip_itm_out,
           ev_rule_status,
           ev_rule_message,
           ev_trips_proc,
           ev_trips_elig,
           rv_subrc.

    TRY.
        " Dynamic function call with standard interface
        CALL FUNCTION iv_fm_name
          EXPORTING
            iv_simulation_mode = p_simul
          TABLES
            it_trip_hdr        = it_trip_hdr_in
            it_trip_itm        = it_trip_itm_in
            et_trip_hdr        = et_trip_hdr_out
            et_trip_itm        = et_trip_itm_out
          IMPORTING
            ev_rule_status     = ev_rule_status
            ev_rule_message    = ev_rule_message
            ev_trips_processed = ev_trips_proc
            ev_trips_eligible  = ev_trips_elig
          EXCEPTIONS
            system_error       = 1
            OTHERS             = 2.

        IF sy-subrc <> 0.
          rv_subrc = sy-subrc.
          ev_rule_status = gc_rule_error.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            INTO ev_rule_message.
        ENDIF.

      CATCH cx_root INTO DATA(lo_exc).
        rv_subrc = 8.
        ev_rule_status = gc_rule_error.
        ev_rule_message = lo_exc->get_text( ).
    ENDTRY.
  ENDMETHOD.

  METHOD execute_calculation_rule.
    DATA: lw_calc_rule      TYPE gty_rulemap_proc,
          lt_trip_hdr_in    TYPE gty_t_trip_hdr,
          lt_trip_itm_in    TYPE gty_t_trip_itm,
          lt_trip_hdr_out   TYPE gty_t_trip_hdr,
          lt_trip_itm_out   TYPE gty_t_trip_itm,
          lw_trip_hdr_out   TYPE zsce_ctd_hdr,
          lv_calc_status    TYPE char1,
          lv_calc_message   TYPE string,
          lv_condition_met  TYPE abap_bool,
          lv_dummy1         TYPE i,
          lv_dummy2         TYPE i.

    CLEAR rv_subrc.

    " Read the calc rule
    READ TABLE it_calc_rules INTO lw_calc_rule INDEX 1.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    " Check execution condition (if specified)
    IF lw_calc_rule-exec_condition IS NOT INITIAL.
      lv_condition_met = me->evaluate_condition(
        EXPORTING
          is_trip_hdr  = cs_trip_hdr
          it_trip_itm  = ct_trip_itm
          iv_condition = lw_calc_rule-exec_condition ).

      IF lv_condition_met = abap_false.
        me->add_log_message(
          iv_msgty  = 'I'
          iv_msgtext = 'Calculation condition not met'
          iv_param1  = space
          iv_param2  = cs_trip_hdr-trip_no ).
        RETURN.
      ENDIF.
    ENDIF.

    " Call calculation function module
    APPEND cs_trip_hdr TO lt_trip_hdr_in.
    lt_trip_itm_in = ct_trip_itm.

    rv_subrc = me->call_rule_fm(
      EXPORTING
        iv_fm_name      = lw_calc_rule-fm_name
        it_trip_hdr_in  = lt_trip_hdr_in
        it_trip_itm_in  = lt_trip_itm_in
      IMPORTING
        et_trip_hdr_out = lt_trip_hdr_out
        et_trip_itm_out = lt_trip_itm_out
        ev_rule_status  = lv_calc_status
        ev_rule_message = lv_calc_message
        ev_trips_proc   = lv_dummy1
        ev_trips_elig   = lv_dummy2 ).

    " Update working tables if calculation succeeded
    IF lv_calc_status = gc_rule_success.
      READ TABLE lt_trip_hdr_out INTO lw_trip_hdr_out INDEX 1.
      IF sy-subrc = 0.
        cs_trip_hdr = lw_trip_hdr_out.
      ENDIF.
      ct_trip_itm = lt_trip_itm_out.

      " Append calculation message
      me->append_remark(
        EXPORTING
          iv_remark = lv_calc_message
        CHANGING
          cv_remarks = cs_trip_hdr-ctd_ruleeng_remarks ).

      me->add_log_message(
        iv_msgty  = 'S'
        iv_msgtext = lv_calc_message
        iv_param1  = space
        iv_param2  = cs_trip_hdr-trip_no ).
    ELSE.
      me->add_log_message(
        iv_msgty  = 'W'
        iv_msgtext = 'Calculation failed'
        iv_param1  = space
        iv_param2  = cs_trip_hdr-trip_no ).
    ENDIF.
  ENDMETHOD.

  METHOD evaluate_condition.
    " Simple condition evaluation
    " Example: "CTD_ELIGIBLE = X"
    DATA: lw_trip_itm TYPE zsce_ctd_itm.

    rv_result = abap_true.  " Default to true

    IF iv_condition CS 'CTD_ELIGIBLE'.
      " Check if any item is CTD eligible
      READ TABLE it_trip_itm INTO lw_trip_itm
        WITH KEY ctd_eligible = 'X'.
      IF sy-subrc = 0.
        rv_result = abap_true.
      ELSE.
        rv_result = abap_false.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD update_database.
    DATA: lv_hdr_count TYPE i,
          lv_itm_count TYPE i,
          lo_exc       TYPE REF TO cx_root,
          lv_error_text TYPE string.

    CLEAR rv_subrc.

    TRY.
        " Update Trip Headers
        DESCRIBE TABLE gt_trip_hdr LINES lv_hdr_count.
        IF lv_hdr_count > 0.
          MODIFY zsce_ctd_hdr FROM TABLE gt_trip_hdr.
          IF sy-subrc <> 0.
            rv_subrc = 4.
            me->add_log_message(
              iv_msgty  = 'E'
              iv_msgtext = 'Failed to update ZSCE_CTD_HDR'
              iv_param1  = space
              iv_param2  = space ).
            ROLLBACK WORK.
            RETURN.
          ENDIF.

          me->add_log_message(
            iv_msgty  = 'S'
            iv_msgtext = 'Trip headers updated'
            iv_param1  = lv_hdr_count
            iv_param2  = space ).
        ENDIF.

        " Update Trip Items
        DESCRIBE TABLE gt_trip_itm LINES lv_itm_count.
        IF lv_itm_count > 0.
          MODIFY zsce_ctd_itm FROM TABLE gt_trip_itm.
          IF sy-subrc <> 0.
            rv_subrc = 4.
            me->add_log_message(
              iv_msgty  = 'E'
              iv_msgtext = 'Failed to update ZSCE_CTD_ITM'
              iv_param1  = space
              iv_param2  = space ).
            ROLLBACK WORK.
            RETURN.
          ENDIF.

          me->add_log_message(
            iv_msgty  = 'S'
            iv_msgtext = 'Trip items updated'
            iv_param1  = lv_itm_count
            iv_param2  = space ).
        ENDIF.

        " Commit work
        COMMIT WORK AND WAIT.

        me->add_log_message(
          iv_msgty  = 'S'
          iv_msgtext = 'Database commit successful'
          iv_param1  = space
          iv_param2  = space ).

      CATCH cx_root INTO lo_exc.
        lv_error_text = lo_exc->get_text( ).
        rv_subrc = 8.
        me->add_log_message(
          iv_msgty  = 'E'
          iv_msgtext = lv_error_text
          iv_param1  = space
          iv_param2  = space ).
        ROLLBACK WORK.
    ENDTRY.
  ENDMETHOD.

  METHOD display_results.
    IF p_fgnd = 'X'.
      " Foreground mode - display ALV
      me->prepare_alv_output( ).
      me->display_alv( ).
    ELSE.
      " Background mode - write to job log
      me->write_job_log( ).
    ENDIF.

    " Save application log
    me->save_application_log( ).
  ENDMETHOD.

  METHOD prepare_alv_output.
    DATA: lw_alv_output TYPE gty_alv_output,
          lw_trip_proc  TYPE gty_trip_proc,
          lv_timestamp  TYPE char20,
          lw_trip_itm   TYPE zsce_ctd_itm.

    CLEAR gt_alv_output.

    LOOP AT gt_trip_proc INTO lw_trip_proc.
      CLEAR lw_alv_output.

      lw_alv_output-trip_no = lw_trip_proc-trip_no.
      lw_alv_output-lifnr = lw_trip_proc-lifnr.
      lw_alv_output-truck_no = lw_trip_proc-truck_no.
      lw_alv_output-rulemap_id = lw_trip_proc-rulemap_id.
      lw_alv_output-rule_seq = lw_trip_proc-rule_seq.
      lw_alv_output-prev_status = lw_trip_proc-prev_status.
      lw_alv_output-new_status = lw_trip_proc-trip_status.
      lw_alv_output-exec_status = lw_trip_proc-exec_status.
      lw_alv_output-exec_message = lw_trip_proc-exec_message.

      " Check if any item is CTD eligible
      READ TABLE gt_trip_itm INTO lw_trip_itm
        WITH KEY trip_no = lw_trip_proc-trip_no
                 ctd_eligible = 'X'.
      IF sy-subrc = 0.
        lw_alv_output-ctd_eligible = 'X'.
      ENDIF.

      " Format timestamp
      WRITE lw_trip_proc-processed_on TO lv_timestamp
        TIMEZONE sy-zonlo.
      lw_alv_output-processed_on = lv_timestamp.

      APPEND lw_alv_output TO gt_alv_output.
    ENDLOOP.
  ENDMETHOD.

  METHOD display_alv.
    DATA: lt_fieldcat TYPE lvc_t_fcat,
          lw_layout   TYPE lvc_s_layo,
          lv_title    TYPE lvc_title,
          lv_msg      TYPE string.

    " Build field catalog
    me->build_fieldcat( CHANGING ct_fieldcat = lt_fieldcat ).

    " Build layout
    lw_layout-zebra = 'X'.
    lw_layout-cwidth_opt = 'X'.
    lw_layout-sel_mode = 'A'.

    " Title
    CONCATENATE 'CTD Rule Engine Execution Results -'
                gv_trips_proc 'Trips Processed,'
                gv_trips_eligible 'Eligible'
      INTO lv_title SEPARATED BY space.

    " Display ALV
    CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY_LVC'
      EXPORTING
        i_callback_program = sy-repid
        is_layout_lvc      = lw_layout
        it_fieldcat_lvc    = lt_fieldcat
        i_grid_title       = lv_title
        i_save             = 'A'
      TABLES
        t_outtab           = gt_alv_output
      EXCEPTIONS
        program_error      = 1
        OTHERS             = 2.

    IF sy-subrc <> 0.
      MESSAGE 'Error displaying ALV' TYPE 'I' DISPLAY LIKE 'E'.
    ENDIF.
  ENDMETHOD.

  METHOD build_fieldcat.
    DATA: lw_fieldcat TYPE lvc_s_fcat.

    CLEAR ct_fieldcat.

    " Trip Number
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'TRIP_NO'.
    lw_fieldcat-scrtext_l = 'Trip Number'.
    lw_fieldcat-col_pos = 1.
    lw_fieldcat-outputlen = 14.
    lw_fieldcat-key = 'X'.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Vendor
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'LIFNR'.
    lw_fieldcat-scrtext_l = 'Vendor'.
    lw_fieldcat-col_pos = 2.
    lw_fieldcat-outputlen = 10.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Truck Number
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'TRUCK_NO'.
    lw_fieldcat-scrtext_l = 'Truck Number'.
    lw_fieldcat-col_pos = 3.
    lw_fieldcat-outputlen = 15.
    APPEND lw_fieldcat TO ct_fieldcat.

    " RuleMap ID
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'RULEMAP_ID'.
    lw_fieldcat-scrtext_l = 'RuleMap ID'.
    lw_fieldcat-col_pos = 4.
    lw_fieldcat-outputlen = 20.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Rule Sequence
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'RULE_SEQ'.
    lw_fieldcat-scrtext_l = 'Rules Executed'.
    lw_fieldcat-col_pos = 5.
    lw_fieldcat-outputlen = 20.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Previous Status
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'PREV_STATUS'.
    lw_fieldcat-scrtext_l = 'Prev Status'.
    lw_fieldcat-col_pos = 6.
    lw_fieldcat-outputlen = 10.
    APPEND lw_fieldcat TO ct_fieldcat.

    " New Status
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'NEW_STATUS'.
    lw_fieldcat-scrtext_l = 'New Status'.
    lw_fieldcat-col_pos = 7.
    lw_fieldcat-outputlen = 10.
    APPEND lw_fieldcat TO ct_fieldcat.

    " CTD Eligible
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'CTD_ELIGIBLE'.
    lw_fieldcat-scrtext_l = 'CTD Eligible'.
    lw_fieldcat-col_pos = 8.
    lw_fieldcat-outputlen = 12.
    lw_fieldcat-checkbox = 'X'.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Execution Status
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'EXEC_STATUS'.
    lw_fieldcat-scrtext_l = 'Exec Status'.
    lw_fieldcat-col_pos = 9.
    lw_fieldcat-outputlen = 12.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Execution Message
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'EXEC_MESSAGE'.
    lw_fieldcat-scrtext_l = 'Message'.
    lw_fieldcat-col_pos = 10.
    lw_fieldcat-outputlen = 50.
    APPEND lw_fieldcat TO ct_fieldcat.

    " Processed On
    CLEAR lw_fieldcat.
    lw_fieldcat-fieldname = 'PROCESSED_ON'.
    lw_fieldcat-scrtext_l = 'Processed On'.
    lw_fieldcat-col_pos = 11.
    lw_fieldcat-outputlen = 20.
    APPEND lw_fieldcat TO ct_fieldcat.
  ENDMETHOD.

  METHOD write_job_log.
    WRITE: / 'CTD Rule Engine Execution Summary'.
    WRITE: / '===================================='.
    WRITE: / 'Execution Date:', sy-datum.
    WRITE: / 'Execution Time:', sy-uzeit.
    WRITE: / 'User:', sy-uname.
    WRITE: / 'Simulation Mode:', p_simul.
    WRITE: / ''.
    WRITE: / 'Processing Statistics:'.
    WRITE: / '  Trips Fetched    :', gv_trips_fetched.
    WRITE: / '  Trips Processed  :', gv_trips_proc.
    WRITE: / '  Trips Eligible   :', gv_trips_eligible.
    WRITE: / '  Trips with Errors:', gv_trips_error.
    WRITE: / '  Processing Time  :', gv_runtime, 'seconds'.
    WRITE: / ''.
    WRITE: / 'See application log (SLG1) for detailed results'.
    WRITE: / 'Log Object: ZCTD_RULEENG'.
  ENDMETHOD.

  METHOD init_application_log.
    DATA: lw_log TYPE bal_s_log,
          lv_extnumber TYPE balnrext.

    " Create external number (date + time)
    CONCATENATE sy-datum sy-uzeit INTO lv_extnumber.

    lw_log-object = gc_log_object.
    lw_log-subobject = gc_log_subobject.
    lw_log-extnumber = lv_extnumber.
    lw_log-aldate = sy-datum.
    lw_log-altime = sy-uzeit.
    lw_log-aluser = sy-uname.
    lw_log-alprog = sy-repid.

    CALL FUNCTION 'BAL_LOG_CREATE'
      EXPORTING
        i_s_log      = lw_log
      IMPORTING
        e_log_handle = gv_log_handle
      EXCEPTIONS
        OTHERS       = 1.

    IF sy-subrc <> 0.
      MESSAGE 'Failed to initialize application log' TYPE 'I'.
    ENDIF.
  ENDMETHOD.

  METHOD add_log_message.
    DATA: lw_msg TYPE bal_s_msg,
          lv_text TYPE char200.

    lw_msg-msgty = iv_msgty.

    " Convert message text
    lv_text = iv_msgtext.

    " Use free text message
    CALL FUNCTION 'BAL_LOG_MSG_ADD_FREE_TEXT'
      EXPORTING
        i_log_handle = gv_log_handle
        i_msgty      = iv_msgty
        i_text       = lv_text
      EXCEPTIONS
        OTHERS       = 1.
  ENDMETHOD.

  METHOD save_application_log.
    DATA: lt_handles TYPE bal_t_logh.

    APPEND gv_log_handle TO lt_handles.

    CALL FUNCTION 'BAL_DB_SAVE'
      EXPORTING
        i_t_log_handle   = lt_handles
        i_save_all       = 'X'
      EXCEPTIONS
        log_not_found    = 1
        save_not_allowed = 2
        numbering_error  = 3
        OTHERS           = 4.

    IF sy-subrc = 0.
      MESSAGE 'Application log saved successfully' TYPE 'S'.
    ELSE.
      MESSAGE 'Failed to save application log' TYPE 'I' DISPLAY LIKE 'W'.
    ENDIF.
  ENDMETHOD.

  METHOD log_execution_summary.
    DATA: lv_message TYPE string.

    CONCATENATE 'Execution Summary: Processed' gv_trips_proc
                'trip(s),' gv_trips_eligible 'eligible,'
                gv_trips_error 'error(s)'
      INTO lv_message SEPARATED BY space.

    me->add_log_message(
      iv_msgty  = 'S'
      iv_msgtext = lv_message
      iv_param1  = space
      iv_param2  = space ).
  ENDMETHOD.

  METHOD append_remark.
    DATA: lv_temp TYPE string,
          lv_len  TYPE i.

    IF cv_remarks IS INITIAL.
      cv_remarks = iv_remark.
    ELSE.
      CONCATENATE cv_remarks '; ' iv_remark INTO lv_temp.
      lv_len = strlen( lv_temp ).
      IF lv_len <= gc_max_remarks.
        cv_remarks = lv_temp.
      ELSE.
        " Truncate if exceeds max length
        cv_remarks = lv_temp(gc_max_remarks).
      ENDIF.
    ENDIF.
  ENDMETHOD.

ENDCLASS.
